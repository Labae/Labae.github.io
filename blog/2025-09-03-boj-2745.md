---
layout: post
title: "[백준] 2745 - 진법 변환"
date: 2025-09-03
categories: [PS, 백준, 수학]
tags: [cpp, 브론즈]
---

## 📌 문제 정보

<div style="display: flex; gap: 10px; margin-bottom: 20px;">
    <img src="https://img.shields.io/badge/플랫폼-백준-gold?style=flat-square" alt="백준" />
    <img src="https://img.shields.io/badge/난이도-브론즈2-CD7F32?style=flat-square" alt="브론즈2" />
    <img src="https://img.shields.io/badge/분류-수학-blue?style=flat-square" alt="수학" />
</div>

**문제 링크:** [백준 2745 - 진법 변환](https://www.acmicpc.net/problem/2745)

## 📖 문제 설명

B진법 수 N이 주어진다. 이 수를 10진법으로 바꿔 출력하는 프로그램을 작성하시오.

10진법을 넘어가는 진법은 숫자로 표시할 수 없는 자리가 있다. 이런 경우에는 다음과 같이 알파벳 대문자를 사용한다.

A: 10, B: 11, ..., F: 15, ..., Y: 34, Z: 35

### 입력
첫째 줄에 N과 B가 주어진다. 

B진법 수 N을 10진법으로 바꾸면, 항상 10억보다 작거나 같다.

### 출력
첫째 줄에 B진법 수 N을 10진법으로 출력한다.

### 제한사항
- (2 ≤ B ≤ 36)
- 결과값은 항상 10억보다 작거나 같다.

### 예제 입력/출력

**예제 1**
| 입력 | 출력 |
|------|------|
| ZZZZZ 36 | 60466175 |

## 🎯 접근 방법

### 1. 문제 분석
- B진법 수를 10진법으로 변환하는 문제
- 숫자(0-9)와 알파벳(A-Z)을 적절한 값으로 변환 필요
- 진법 변환 공식: 각 자리수x(진법^자릿수)의 합

### 2. 알고리즘 설계
1. Horner's method활용: 문자열을 왼쪽부터 읽으면서 `결과 = 결과 * B + 현재 자리값`

### 3. 시간 복잡도
- O(N): 문자열 길이만큼 순회

## 💡 시도한 방법들

### 첫 번째 시도(틀린 접근)
unordered_map을 사용하고 문자열을 뒤집어서 처리하려고 했습니다.

```cpp
int main() {
    unordered_map<char, int> um;
    
    int num = 10;
    for (char ch = 'A'; ch <= 'Z'; ch++) {
        um[ch] = num++;
    }
    
    string N;
    int B;
    cin >> N >> B;
    
    int base = 1;
    reverse(N.begin(), N.end());
    long long result = 0;
    
    for (int i = 0; i < N.size(); i++) {
        int num = isalpha(N[i]) ? um[N[i]] : N[i] - '0';
        result += num * (base * (i+1));  // 문제: 잘못된 계산
        base *= B;
    }
}
```

문제점:
1. base * (i+1) 부분이 잘못됨 - 단순히 base를 사용해야 함
2. unordered_map이 불필요 - 간단한 계산으로 처리 가능
3. 문자열을 뒤집을 필요 없음 - Horner's method 사용하면 앞에서부터 처리 가능

## ✅ 최종 풀이

```cpp
#include <iostream>
#include <string>
#include <cctype>

int main() {
	std::ios_base::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	std::string N;
	int B;
	std::cin >> N >> B;

	int result = 0;
	for (int i = 0; i < N.length(); i++) {
		if (isdigit(N[i])) {
			result = result * B + (N[i] - '0');
		}
		else {
			result = result * B + (N[i] - 'A' + 10);
		}
	}

	std::cout << result << '\n';

	return 0;
}
```

## 🔑 핵심 포인트

1. **Horner's Method**
   - `result = result * B + digit` 형태로 계산

2. **문자 변환**
   - 숫자(0-9): `char - '0'`
   - 알파벳(A-Z): `char - 'A' + 10`
   - `isdigit()` 함수로 구분

3. **자료형 선택**
   - 결과가 언제나 10억 이하이므로 `int`로 충분

## 📊 결과
- **메모리:** 2028 KB
- **시간:** 0 ms
- **언어:** C++20
- **결과:** 맞았습니다!!

---

### 💬 댓글
문제에 대한 질문이나 다른 풀이 방법이 있다면 아래 댓글로 공유해주세요!